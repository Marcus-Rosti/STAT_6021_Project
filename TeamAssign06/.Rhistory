mean(exp(x))
x<-rnorm(10000)
mean(exp(x))
x<-rnorm(100000)
mean(exp(x))
x<-rnorm(100000)
mean(exp(x))
x<-rnorm(10000000)
mean(exp(x))
sqrt(exp(1))
library(MASS)
library(ISLR)
names(Boston)
attach(Boston)
lm.fit=lm(medvâˆ¼lstat)
lm.fit=lm(medv~lstat)
summary(lm.fit)
plot(lm.fit)
Plot(medv~lstat)
plot(medv~lstat)
confint(lm.fit)
plot(lstat,medv)
abline(lm.fit)
abline(lm.fit,lwd=3)
abline(lm.fit,lwd=3,col="red")
plot(hatvalues(lm.fit))
lm.fit<-lm(medv~lstat+age)
summary(lm.fit)
plor(lm.fit)
plot(lm.fit)
plot(age~medv)
plot(medv~age)
summary(lm(medv~.))
summary(lm(medv~.,data=Boston))
summary(lm(medv~lstat * age))
summary(lm(medv~lstat +I(lstat^2)))
non.lin<-lm(medv~lstat +I(lstat^2))
plot(non.lin)
summary(lm(medv~I(log(lstat))))
plot(lm(medv~I(log(lstat))))
detach(Boston)
attach(carseats)
attach(Carseats)
detach(Carseats)
attach(Default)
plot(balance~student)
plot(balance~income)
attach(auto)
View(auto)
library("ISLR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
summary(auto)
plot(mpg~weight)
plot(mpg~horsepower)
plot(mpg~acceleration)
plot(mpg~origin)
plot(mpg~year)
plot(mpg)
sum(mpg)
sum(weight)
model<-lm(mpg~horsepower)
summary(mdoel)
summary(model)
model<-lm(mpg~year)
summary(model)
model
plot(model)
plot(mpg~year)
abline(model)
abline(model,col="red")
plot(mpg~year)
plot(model)
library("ISLR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
View(auto)
4^3
c(2,3,4,5)    # C stands for "combine" or "concatenate."
c(2,3,4,5) + c(1,4,2,3)
c(2,3,4,5) + c(1,4,2)
c(2,3,4,5) + c(1,4,2,3)
c(2,3,4)*2
c(2,3,4,5) + c(5,10)
c(2,3,4,5,6) + c(1,2)
(1:11) %% 2
v[(2,6,8)]
1:11 %% 2
(1:11) %% 2 == 1  # True when element odd
v[(1:11) %% 2 == 1]   # Extracts every other entry of v
v[v %% 2 == 1]   # Extracts the odd entries of v
(1:11)[v %% 2 == 1]  # Positions of odd entries of v
v <- 10:20
v
v[2]
v[4:7]
v[-5]
v[9:7]
v[c(2,6,8)]
v[(2,6,8)]
v[(1:11) %% 2 == 1]   # Extracts every other entry of v
v[v %% 2 == 1]   # Extracts the odd entries of v
(1:11)[v %% 2 == 1]  # Positions of odd entries of v
m <- matrix(1:12, nrow=3, ncol=4)  # Defines a 3-by-4 matrix
m
m <- matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
m
m[2,3]   # Entry in row 2, column 3
m[,3]   # Column 3
m[1:2,3:4]   # Entries in rows 1 or 2 AND cols 3 or 4
which(R)
install.packages("clusterGeneration")
install.packages("e1071")
install.packages("forecast")
install.packages(c("boot", "car", "class", "cluster", "codetools", "curl", "foreign", "KernSmooth", "lattice", "lme4", "MASS", "Matrix", "mgcv", "nlme", "nnet", "pls", "quantreg", "R6", "Rcpp", "rgl", "rJava", "rpart", "scales", "SparseM", "spatial", "survival"))
install.packages(c("nlme", "quantreg", "rgl"))
fs
load("~/MSDS/Fall/DS_6001/inclass2/dw2.RData")
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
library(ggplot2)
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p
p <- p + points( x = agg$Group.1, y = agg$x, col = 'Red', pch = agg$MAX, cex = 10)
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX)) + scale_area()
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX, col='Red'))
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX*10, col='Red'))
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX, color='Red'))
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p + scale_size_continuous(range = c(3,8))
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p + scale_size_continuous(range = c(10,100))
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX))
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)+ theme(legend.position="none")
p <- ggplot(agg, aes(x = Group.1, y = x))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX),color='Red')
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)+ theme(legend.position="none")
help(circles)
help(circle)
p <- ggplot(agg, aes(x = Group.1, y = x,xlab = "Damage", ylab = "Year"))
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX),color='Red')
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)+ theme(legend.position="none")
p <- ggplot(agg, aes(x = Group.1, y = x)) + xlab("Damage") + ylab("Year")
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX),color='Red')
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)+ theme(legend.position="none")
p <- ggplot(agg, aes(x = Group.1, y = x)) + ylab("Damage") + xlab("Year")
p <- p + geom_line()
p <- p + geom_point(aes(size = agg$MAX),color='Red')
p <- p + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
p + scale_size_continuous(range = c(10,100)) + guides(fill=FALSE)+ theme(legend.position="none")
setwd("~/Git/STAT_6021_Project/TeamAssign06")
trees <- read.csv("trees.csv", header=T)
plot(trees$x, trees$y, col="dark green")
r <- 37
Pi
pi
a = pi * r ^2
lambda <- (750 + 2*r) ^ 2
A <- (750 + 2*r) ^ 2
p_i = a/A
p_i <- a/A
sqrt(400)
t <- 1:100000
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub<-subset(trees,(trees$x-x1)^2+(trees$y-y1)^2<=37^2))
trees.sub<-subset(trees,(trees$x-x1)^2+(trees$y-y1)^2<=37^2)))
trees.sub<-subset(trees,(trees$x-x1)^2+(trees$y-y1)^2<=37^2)
plot(trees.sub)
plot(trees.sub$x,trees.sub$y)
plot(trees.sub$x,trees.sub$y,ylim = c(0,750))
plot(trees.sub$x,trees.sub$y,ylim = c(0,750),xlim=x(0,750))
plot(trees.sub$x,trees.sub$y,ylim = c(0,750),xlim=c(0,750))
View(trees.sub)
loop_lim <- 10
ba_area_estimate <- 0
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
r <- 37
a <- pi * r ^ 2
A <- (750 + 2 * r) ^ 2
pi_i <- a / A
################################################################################
#
# Matasuyama's example
#
################################################################################
loop_lim <- 10
ba_area_estimate <- 0
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
loop_lim <- 100
ba_area_estimate <- 0
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
loop_lim <- 100000
ba_area_estimate <- 0
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
ba_actual <- 311.906
percent_bias <- 100 * (ba_area_estimate - ba_actual)/ba_actual
loop_lim <- 100000
ba_area_estimate <- 0
start <- proc.time()
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
total_time <- proc.time() - start
percent_bias <- 100 * (ba_area_estimate - ba_actual)/ba_actual
loop_lim <- 100000
ba_area_estimate <- 0
start <- proc.time()
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + 1/pi_i*sum(trees.sub$ba)/loop_lim
}
total_time <- proc.time() - start
percent_bias <- 100 * (ba_area_estimate - ba_actual)/ba_actual
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
r <- 37
a <- pi * r ^ 2
A <- (750 + 2 * r) ^ 2
pi_i <- a / A
ba_area_estimate <- 0
loop_lim <- 100000
loop_lim <- 10
start <- proc.time()
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + (1/pi_i)*sum(trees.sub$ba)/loop_lim
}
total_time <- proc.time() - start
percent_bias <- 100 * (ba_area_estimate - ba_actual)/ba_actual
ba_area_estimate_values <- rep(0,loop_lim)
loop_lim <- 10000
ba_area_estimate <- 0
ba_area_estimate_values <- rep(0,loop_lim)
start <- proc.time()
for (i in 1:loop_lim) {
x1 <- runif(1,-r, 750 + r)
y1 <- runif(1,-r, 750 + r)
trees.sub <- subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^
2)
ba_area_estimate <- ba_area_estimate + (1/pi_i)*sum(trees.sub$ba)/loop_lim
ba_area_estimate_values[i] <- (1/pi_i)*sum(trees.sub$ba)
}
total_time <- proc.time() - start
average(ba_area_estimate_values)
mean(ba_area_estimate_values)
ba_area_estimate
mse <- 100*sqrt(var(ba_area_estimate_values))/ba_actual
percent_bias <- 100 * (ba_area_estimate - ba_actual)/ba_actual
total_time
10^5
10*10*10*10*10
loop_lim <- 10^5
loop_lim <- 10^4
loop_lim <- 10^5
overlap.area <- function(xt,yt,rl) {
dx <- min(xt, 750 - xt)
dy <- min(yt, 750 - yt)
if (dx >= rl & dy >= rl) {
area <- pi * rl ^ 2
} else {
if (dx < rl & dy >= rl) {
if (dx >= 0) {
area <- (pi - acos(dx / rl)) * rl ^ 2 + dx * sqrt(rl ^ 2 - dx ^ 2)
} else {
ndx <- -dx
area <-
acos(ndx / rl) * rl ^ 2 - ndx * sqrt(rl ^ 2 - ndx ^ 2)
}
}
if (dx >= rl & dy < rl) {
if (dy >= 0) {
area <- (pi - acos(dy / rl)) * rl ^ 2 + dy * sqrt(rl ^ 2 - dy ^ 2)
} else {
ndy <- -dy
area <-
acos(ndy / rl) * rl ^ 2 - ndy * sqrt(rl ^ 2 - ndy ^ 2)
}
}
if (dx < rl & dy < rl & (dx ^ 2 + dy ^ 2) >= rl ^ 2) {
if (dx >= 0 & dy >= 0) {
area <-
(pi - acos(dx / rl) - acos(dy / rl)) * rl ^ 2 + dx * sqrt(rl ^ 2 - dx ^
2) + dy * sqrt(rl ^ 2 - dy ^ 2)
}
if (dx >= 0 & dy < 0) {
ndy <- -dy
area <-
acos(ndy / rl) * rl ^ 2 - ndy * sqrt(rl ^ 2 - ndy ^ 2)
}
if (dx < 0 & dy >= 0) {
ndx <- -dx
area <-
acos(ndx / rl) * rl ^ 2 - ndx * sqrt(rl ^ 2 - ndx ^ 2)
}
if (dx < 0 & dy < 0) {
area <- 0
}
}
}
}
overlap.area(750,750,1)
overlap.area(749,749,1)
overlap.area <- function(xt,yt,rl) {
dx <- min(xt, 750 - xt)
dy <- min(yt, 750 - yt)
if (dx >= rl & dy >= rl) {
area <- pi * rl ^ 2
} else {
if (dx < rl & dy >= rl) {
if (dx >= 0) {
area <- (pi - acos(dx / rl)) * rl ^ 2 + dx * sqrt(rl ^ 2 - dx ^ 2)
} else {
ndx <- -dx
area <-
acos(ndx / rl) * rl ^ 2 - ndx * sqrt(rl ^ 2 - ndx ^ 2)
}
}
if (dx >= rl & dy < rl) {
if (dy >= 0) {
area <- (pi - acos(dy / rl)) * rl ^ 2 + dy * sqrt(rl ^ 2 - dy ^ 2)
} else {
ndy <- -dy
area <-
acos(ndy / rl) * rl ^ 2 - ndy * sqrt(rl ^ 2 - ndy ^ 2)
}
}
if (dx < rl & dy < rl & (dx ^ 2 + dy ^ 2) >= rl ^ 2) {
if (dx >= 0 & dy >= 0) {
area <-
(pi - acos(dx / rl) - acos(dy / rl)) * rl ^ 2 + dx * sqrt(rl ^ 2 - dx ^
2) + dy * sqrt(rl ^ 2 - dy ^ 2)
}
if (dx >= 0 & dy < 0) {
ndy <- -dy
area <-
acos(ndy / rl) * rl ^ 2 - ndy * sqrt(rl ^ 2 - ndy ^ 2)
}
if (dx < 0 & dy >= 0) {
ndx <- -dx
area <-
acos(ndx / rl) * rl ^ 2 - ndx * sqrt(rl ^ 2 - ndx ^ 2)
}
if (dx < 0 & dy < 0) {
area <- 0
}
}
}
return(area)
}
overlap.area(749,749,1)
overlap.area(750,750,1)
overlap.area(300,300,1)
overlap.area(749,749,10)
overlap.area <- function(xt,yt,rl) {
dx <- min(xt, 750-xt)
dy <- min(yt, 750-yt)
if (dx >= rl & dy >= rl) {
area <- pi*rl^2
} else {
if (dx < rl & dy >= rl) {
if (dx >= 0) {
area <- (pi - acos(dx/rl))*rl^2 + dx*sqrt(rl^2 - dx^2)
} else {
ndx <- -dx
area <- acos(ndx/rl)*rl^2 - ndx*sqrt(rl^2 - ndx^2)
}
}
if (dx >= rl & dy < rl) {
if (dy >= 0) {
area <- (pi - acos(dy/rl))*rl^2 + dy*sqrt(rl^2 - dy^2)
} else {
ndy <- -dy
area <- acos(ndy/rl)*rl^2 - ndy*sqrt(rl^2 - ndy^2)
}
}
if (dx < rl & dy < rl & (dx^2 + dy^2) >= rl^2) {
if (dx >= 0 & dy >= 0) {
area <- (pi-acos(dx/rl)-acos(dy/rl))*rl^2 + dx*sqrt(rl^2-dx^2)+dy*sqrt(rl^2-dy^2)
}
if (dx >= 0 & dy < 0) {
ndy <- -dy
area <- acos(ndy/rl)*rl^2 - ndy*sqrt(rl^2 - ndy^2)
}
if (dx < 0 & dy >= 0) {
ndx <- -dx
area <- acos(ndx/rl)*rl^2 - ndx*sqrt(rl^2 - ndx^2)
}
if (dx < 0 & dy < 0) {
area <- 0
}
}
if (dx < rl & dy < rl & (dx^2 + dy^2) < rl^2) {
if (dx >= 0 & dy >= 0) {
theta <- (3/2)*pi - acos(dx/rl) - acos(dy/rl)
area <- (theta/2)*rl^2 + 0.5*(dx*sqrt(rl^2-dx^2)+dy*sqrt(rl^2-dy^2)) + dx*dy
}
if (dx >= 0 & dy < 0) {
area1 <- acos(dx/rl)*rl^2 - dx*sqrt(rl^2 - dx^2)
ndy <- -dy
theta <- (3/2)*pi - acos(dx/rl) - acos(ndy/rl)
area2 <- (theta/2)*rl^2 + 0.5*(dx*sqrt(rl^2-dx^2)+ndy*sqrt(rl^2-ndy^2)) + dx*ndy
area <- pi*rl^2 - (area1 + area2)
}
if (dx < 0 & dy >= 0) {
area1 <- acos(dy/rl)*rl^2 - dy*sqrt(rl^2 - dy^2)
ndx <- -dx
theta <- (3/2)*pi - acos(ndx/rl) - acos(dy/rl)
area2 <- (theta/2)*rl^2 + 0.5*(ndx*sqrt(rl^2-ndx^2)+dy*sqrt(rl^2-dy^2)) + ndx*dy
area <- pi*rl^2 - (area1 + area2)
}
if (dx < 0 & dy < 0) {
ndx <- -dx
ndy <- -dy
theta <- (3/2)*pi + asin(ndx/rl) + asin(ndy/rl)
area <- pi*rl^2 - ((theta/2)*rl^2 + 0.5*(ndx*sqrt(rl^2-ndx^2)+ndy*sqrt(rl^2-ndy^2)) - ndx*ndy)
}
}
}
return(area)
}
overlap.area(749,749,10)
overlap.area(749,749,1)
overlap.area(750,750,1)
pi/4
loop_lim <- 10 ^ 5
ba_area_estimate <- 0
ba_area_estimate_values <- rep(0,loop_lim)
start <- proc.time()
A <- 750 ^ 2
for (i in 1:loop_lim) {
x1 <- runif(1, 0, 750)
y1 <- runif(1, 0, 750)
### edit a
a <- overlap.area(x1,y1,r)
pi_i <- a / A
trees.sub <-
subset(trees,(trees$x - x1) ^ 2 + (trees$y - y1) ^ 2 <= 37 ^ 2)
ba_area_estimate <-
ba_area_estimate + (1 / pi_i) * sum(trees.sub$ba) / loop_lim
ba_area_estimate_values[i] <- (1 / pi_i) * sum(trees.sub$ba)
}
total_time <- proc.time() - start
percent_bias <- 100 * (ba_area_estimate - ba_actual) / ba_actual
rmse <- 100 * sqrt(var(ba_area_estimate_values)) / ba_actual
